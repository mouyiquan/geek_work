
### 题目 01- 请你说一说 MySQL 的锁机制
要求：

* 按照锁的粒度，锁的功能来分析
* 什么是死锁，为什么会发生，如何排查？
* 行锁是通过加在什么上完成的锁定？
* 详细说说这条 SQL 的锁定情况：delete from tt where uid = 666;


#### 按照锁的粒度，锁的功能来分析

- 全局锁：锁整Database，flush tables with read lock。
- 表级锁：锁某Table，表锁、元数据锁（MDL），意向锁、AUTO-INC锁。
- 行级锁：锁某Row的索引，也可锁定行索引之间的间隙，由存储引擎实现【InnoDB】

##### 全局锁
###### flush tables with read lock。
场景：全库逻辑备份（MyISAM）
锁：flush tables with read lock。
解锁：unlock tables。

InnoDB备份数据时，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务，切有效的解决了幻读。

##### 表锁
###### 共享锁 读锁
lock tables t_a read;

###### 独占锁 写锁
lock tables t_a write;

##### 表级意向锁
```
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```
意向共享锁和意向独占锁是表级锁,不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。意向锁的目的是为了快速判断表里是否有记录被加锁。而不必去扫描全表。

###### 元数据锁 (MDL)
- 对一张表进行CURD时进行的是读锁
- 对表结构修改时进行的是写锁

问：**为什么线程因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？**

答：这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。所以在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁。

###### AUTO_INC 自增锁
在mysql现版本中，InnoDB通过轻量级锁实现，插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。

innodb_autoinc_lock_mode


- innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁
- innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- innodb_autoinc_lock_mode = 1：
  ◦ &nbsp;普通 insert 语句，自增锁在申请之后就马上释放；
  ◦ 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。

binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，而不是执行语句，导致主备不一致。

###### 查看表级锁情况
show open tables;

##### 行锁
行级锁为InnoDB独有，通过给索引上的索引项加锁实现。只有通过索引条件检索的数据才会使用行级锁，否则使用表锁。

###### Record Locks
锁索引而非记录本身。
###### Gap Locks
开区间，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象
###### Next-Key Locks
闭区间，也包含间隙锁。

###### 插入意向锁

插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。

#### 什么是死锁，为什么会发生，如何排查？

A事务锁住了记录1，B事务锁住了记录2，A事务去拿记录2，且不释放记录1，一直等待，B是相同的操作，导致事务A/B阻塞，发生死锁。

死锁的排查：

方法一：通过arthas工具，由阿里开源。通过thread -b命令查看死锁。
```attention：arthas的thread -b命令只能排查**synchronized**的死锁信息，官方有注释！！！```

方法二：

1. top 查看CPU占用是否是java
2. top -Hp [javaPid] 查看线程CPU的占用状态，找到长时间占用的pid
3. 使用jstack pid获取栈的信息，去找locked和waiting
4. 根据线程名称或则其他的信息找到对应的代码进行分析

``` 推荐：线程尽量使用线程名称，见名知其意。```


#### 行锁是通过加在什么上完成的锁定？

有索引加索引，没索引加到表锁

#### 详细说说这条 SQL 的锁定情况：delete from tt where uid = 666;

##### 隔离级别RC

1. uid是主键： 锁主键
2. uid是唯一索引：根据唯一索引找到对应的（影藏）聚簇索引，锁聚簇索引，2把锁
3. uid是二级非唯一索引：类似唯一索引，不过只是记录变多了
4. uid无索引：扫全表，所有记录锁住，再通过unlock_row方法解锁。



##### 隔离级别RR

1. uid是主键：  锁主键
2. uid是唯一索引：根据唯一索引找到对应的（影藏）聚簇索引，锁聚簇索引，2把锁
3. uid是二级非唯一索引：类似唯一索引，不过只是记录变多了
4. uid无索引：扫全表，所有记录锁住，同时加上间隙锁。

