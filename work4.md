
### 题目 01- 请你说一说什么是线程和进程？
###### 区别
* 一个进程有多个线程，线程是进程的更小单位
* 线程之间是独立的
* 线程是java的最小单位，但是go语言不是，go语言还有比线程更小的协程，更小的资源占用和消耗，所以GO语言天生适合高并发
*
###### 关系
* 线程可以共享进程的资源和变量
* 线程需要向进程获取资源

###### 线程的上下文切换是什么？
背景：在操作系统底层，CPU并不是被一个线程一直占用的，一直占用可能会导致系统卡死，所以CPU是根据时间片划分执行权限的，一个线程只能在一个时间片上执行，除非线程手动释放，否则时间片到会强制剥夺线程的使用。

结果：
* 当线程未执行完而时间片到了，CPU会将当前线程的状态保存起来，比如保存了jvm线程所包含的局部变量、操作数栈等数据。
* 当线程再次获得时间片，CPU会拉取上次保存的数据，重新装载到寄存器进行执行，会从操作数栈中获取下一次指令的地址，通过CS:IP寄存器继续去执行。
* 当大量的线程抢占执行时，就会出现频繁的上下文切换，耗费CPU资源，所以线程代码应该尽量优化，减少时间片的次数

###### 线程的并发与并行有啥区别？
* 并发是抢占式，并行不是，例如三车道三个车并排叫并行，三个车一个车道叫并发。
* 并发需要考虑资源竞争，考虑共享变量的动态

### 题目 02- 使用了多线程会带来什么问题呢？
带来的问题：
* 更多的资源消耗(CPU、内存等)
* 原子性、有序性，可见性
* 更复杂的代码，可维护性会有提升
###### 能不能详细说说线程安全问题？
* 当多线程修改同一个共享变量时，结果不符合预期
* 锁的错误使用应该也算线程安全，比如死锁
###### 原子性、有序性和可见性能不能深入的谈一下。
* 原子性：一段代码，要么执行成功，要么执行失败，不可中间被打扰
* 有序性：CPU和编译器会根据以往的指令执行经验进行优化，可能会打乱执行的顺序，单线程由于有依赖关系等限制不会有执行影响，但是在多线程情况下却会有问题。
* 可见性：线程之间共享变量的更改并不是立马从主存获取的，而是从自己的内存区域去拿，这里就设计了java内存模型了

```注意：volatile只保证线程的有序性和可见性，实现原理是插入内存屏障，storeload，storestore等，在读之前和写之后。```

### 题目 03- 什么是死锁？如何排查死锁?
###### 排查过程最好详细说明，最少说一种排查方案，越多越好。

死锁的定义： 资源a、b，线程A、B，线程A获取了资源a,需要去获取b资源，并且是阻塞等待，B线程获取了b资源，需要去获取a资源，并且是阻塞等待，就会造成死锁。当然这是最简单的死锁。

死锁的排查：

方法一：通过arthas工具，由阿里开源。通过thread -b命令查看死锁。
```attention：arthas的thread -b命令只能排查**synchronized**的死锁信息，官方有注释！！！```

方法二：

1. top 查看CPU占用是否是java
2. top -Hp [javaPid] 查看线程CPU的占用状态，找到长时间占用的pid
3. 使用jstack pid获取栈的信息，去找locked和waiting
4. 根据线程名称或则其他的信息找到对应的代码进行分析

```推荐：线程尽量使用线程名称，见名知其意。```