
### 题目 01：
##### 一条 SQL 语句在 MySQL 中是如何执行的？
**查询语句**：
1.首先进入连接器 连接器会判断账号密码等权限机制
2.判断是否存在对应的缓存，有的话直接返回，没有则进入下一步（8.0取消了缓存，）
3.进行词法分析，相当于用空格进行split操作判断
4.优化器 索引选择，这里会对sql  索引查询进行统计，优化器会进行选择索引
5.执行器 跟执行引擎进行交互

缓存的问题： ①大数据量的查询会占用大量的内存空间，有OOM的风险②大量请求容易施加同一把锁，降低并发性能③缓存一致性问题    
取消缓存的目的：提高数据库的性能和可靠性

**更新语句**：

与查询语句的差别为不需要执行查询环境，但是更新流程设计undo/redo/bin log。

- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
- **binlog （归档日志）**：是 Server 层生成的日志，主要用于数据备份和主从复制；


**为什么需要undo log?**

修改、删除、新增都会产生undo log。
一条记录的每一次操作都会产生一次undo log记录，每一个记录都会有一个trx_id和roll_pointer.
- 通过 trx_id 可以知道该记录是被哪个事务修改的；
- 通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；

undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。

- 读提交: 每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 可重复读: 隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

undo log保存的是旧值的记录。

**为什么需要Buffer Pool?**

InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。

Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。

查询一条记录，缓存的是整页的记录，InnoDB数据加载到Buffer Pool的最小单位是页。

**为什么需要redo log?**

Buffer Pool 降低了磁盘I/O的频次，但是内存总是不可靠的，断点重启就会有脏数据。

WAL： 在操作表数据之前先写日志。而redo log就是该技术的一种落地实现。

redo log价值：
- 实现事务的持久性，记录的是修改记录的新值，而undo log是旧值，可以保证在commit之后redo log日志是落盘而不被丢失的。
- 随机写变顺序写，redo log是顺序写的，虽然更新一条记录的总时间变长了，但是事务的执行时间变短了，减少了锁的开销。

redo log不是直接落盘的，在buffer pool中也有redo log buffer区域。
**redo log buffer落盘策略**：
- 1.MySQL正常关闭时。
- 2.当redo log buffer中记录的写入量大于redo log buffer参数设置申请内存空间的一半时。
- 3.InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。
- 4.每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘。

innodb_flush_log_at_trx_commit 参数：
- 0 ：该模式不会主动的落盘，会执行策略2
- 1 ：该模式执行的是策略4，每次提交都会落盘。
- 2 ：该模式执行的是策略3，写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，交给系统决定是否落盘，有Page cache的概念，如果操作系统崩溃，依然会丢失1s的数据。

innodb_flush_log_at_trx_commit参数比较：
安全性： 1  > 2 > 0
性能： 0  > 2 > 1

默认情况下redo log有2个文件，所以当写满一个文件时，会触发落盘操作，防止数据丢失。

当脏页落盘时，对应的redo log记录实际已经变成废数据。所以redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置。

**如果 write pos 追上了 checkpoint**，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞。必须等待脏数据落盘，清除redo log，check point前移，才会出现新的空间交给redo log去记录新的操作，所以redo log的大小设置非常值得深思。

**为什么需要binlog?**
binlog是MySQL Server层面的日志，而InnoDB是存储引擎层面的日志。

binlog和redo log区别：

|  | redo log | binlog |
| --- | --- | --- |
| 数据量 | 指定大小，会清空 | 全量日志，不会清空 |
| 位置 | 存储引擎 | Server层 |
| 写入方式 | 循环写 | 追加写 |
| 用途 | 掉电等故障恢复 | 主从/备份 |
binlog主从复制分为三个阶段：

1. 主节点写入binlog
2. 主节点同步binlog
3. 从节点根据binlog恢复数据

主从复制模型：

1. 同步复制： 必须所有从节点返回响应。
2. 异步复制： 无须从节点返回响应。
3. 半同步复制： 只要一部分复制成功响应回来就行。

事务执行过程中，先把日志写到 binlog cache，在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。

而binlog也有自己落盘的策略，由sync_binlog控制：

1. sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；
2. sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；
3. sync_binlog =N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。

**为什么需要2阶段提交？**
redo log 和binlog的半成功状态掉电或者程序崩溃情况下会造成数据不一致。
- redo log 提交成功，而binlog未成功，导致从库数据未更新。
- redo log 提交未成功，而binlog成功，导致主库数据恢复，而从库无法恢复。

2阶段提交流程，有点类似http三次握手，两者通过相同的XID确定关系：

1. redo log先到prepare阶段，写入redo log成功之后通知binlog可以开始了
2. binlog写入日志成功，然后通知redo log我写好了
3. redo log收到消息就去修改redo log记录对应的状态，改为commit，执行完之后告诉binlog我ok了



**2阶段提交有什么问题?**

两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差：

- 磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。
- 锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。


组提交：MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数

**Mysql 磁盘I/O很高，优化策略有哪些？**


1. 将 sync_binlog 设置为大于 1 的值，降低刷盘的次数。风险：主机掉电时会丢 N 个事务的 binlog 日志。
2. 将 innodb_flush_log_at_trx_commit 设置为 2，redo log不一定落盘，交给了操作系统，如果主机挂掉也会丢失数据。
3. 修改组提交的参数，用风险换性能

### 题目 02
##### 请解释一下你理解的事务是什么？
要点：

1. 事务四大特性 ACID
- 原子性 要么都成功，要么回滚，都不成功，通过undo log实现
- 一致性 模糊概念，是一种状态到另外一种状态，是一组约束，只要符合规则，那么就是一致性的。一致性也是一种目的，用锁来保证。
- 隔离性 指事务与事务之间的影响，隔离级别有几种，最严格的为串行化，一个事务成功之后另外一个事务才能开始。
- 持久性 指事务一旦提交，只要成功，那么对数据库的修改就是永久性的，不会因为任何原因而改变，包括宕机，通过redo log实现。

2. 事务隔离级别

| 隔离级别 | 脏读 | 不可重复度 | 幻读 |
| --- | --- | --- | --- |
| 读未提交 | 是 | 是 | 是 |
| 读已提交 | 否 | 是 | 是 |
| 可重复读 | 否 | 否 | 是 |
| 串行化 | 否 | 否 | 否 |

InnoDB通过MVCC即多版本的并发控制协议在可重复读的基础上解决了幻读，并且读不加锁，主要是通过undo log, readView, roll_pointer实现的，每个事务都会有自己的trx_id，会根据时间和版本有效的解决幻读问题。

3. 事务会产生的并发问题
   会，死锁
4. 事务的安全性、性能与隔离级别的关系

隔离级别约高，性能约差，安全性越高。




**引用 《MySQL 45 讲》《MySQL 是怎样运行的？》**